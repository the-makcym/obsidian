### Представления

**Представление** - виртуальное отношение, полученное в результате одной или нескольких реляционных операций над существующими отношениями базы данных

Подходы для формирования представления:
1. **Замена представления** - происходит слияние запроса, лежащего в основе представления, и запроса к этому представлению
2. **Материализация представления** - готовое представление хранится в виде временной таблицы, ее актуальность постоянно поддерживается

Исходя из того, что представление есть лишь виртуальное отношение, а не базовая таблица, а относиться мы к представлениям хотим как к базовым таблицам, то встает вопрос, как к ним применять предложения UPDATE, INSERT, DELETE

### Обновляемые представления

Чтобы представление было **обновляемым**, должно существовать взаимно однозначное соответствие между строками представления и базовых таблиц и столбцами представления и базовых таблиц. 

Стандарт ISO определяет следующие критерии обновляемого представления:
- в определении представления не используется оператор DISTINCT, т.е. нет требования на уникальность строк представления
- каждый элемент в списке SELECT представляет собой имя столбца (ну или его псевдоним), но не константу, подзапрос, агрегирующую функцию или иное выражение). В самом деле, нам нужно было бы уметь восстановить параметры функции по ее результату, если бы не было такого ограничения
- в конструкции FROM должна быть указана лишь одна таблица, или, точнее, представление должно быть построено на базе единственной таблицы. Запросы на обновление представления, построенного на базе соединения, объединения, пересечения или разности таблиц должны отклоняться (согласно стандарту), так как если представление есть проекция соединения, объединения, пересечения или разности таблиц, а для столбцов, не входящих в представления, не заданы значения по умолчанию или не разрешены нулевые значения, то обновить такое представление невозможно. 
	Однако, стоит отметить, что, например, объединение подзапросов одной таблицы можно выразить через один запрос к этой таблице, так что обновление такого представление должно иметь место. Т.е. суть проблемы не синтаксическая, а семантическая.
- в конструкцию WHERE не входят подзапросы к таблице, на базе которой представление строится, потому что происходит попытка чтения во время обновления
- в определении представления не должно быть конструкций GROUP BY, HAVING. В самом деле нельзя ведь проводить операции над одной строкой как над группой строк

Тогда СУБД сможет непротиворечивым образом осуществлять обновления представления

Но вообще, некоторые СУБД могут поддерживать чуть более обширные возможности обновления представлений, чем другие, так что в конечном итоге программист сам должен исходя из здравого смысла решать, сможет ли СУБД провести обновление или нет.

### Конструкция WITH CHECK OPTION

Еще одной проблемой при выполнении UPDATE над представлением является появление **мигрирующих строк**, которые в зависимости от значений в конкретных столбцах и выражении WHERE в определении представления могут то появляться в представлении, то исчезать

Для предотвращения этого используется команда WITH [LOCAL / CASCADED] CHECK OPTION при определении представления. Эта команда отвечает за то, чтобы отклонять обновление строки, если строка при этом мигрирует.
Необязательные параметры: если у нас есть цепочка зависимых друг от друга представлений, то WITH CASCADE CHECK OPTION заблокирует у одного из родительских представлений заблокирует обновление с последующей миграцией строки на корню,  а LOCAL может разрешить обновление, но только если по иерархии представлений выше эта строка также мигрирует

#реляционные-бд 